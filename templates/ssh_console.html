<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSH Console - Server {{ server_id }}</title>
    
    <!-- Xterm.js CSS -->
    <link rel="stylesheet" href="/static/xterm/xterm.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1e1e1e;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        #terminal-container {
            width: 100%;
            height: 100%;
            padding: 0;
            background-color: #1e1e1e;
        }
        
        #terminal {
            width: 100%;
            height: 100%;
            padding: 10px;
        }
        
        /* Status bar */
        #status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 30px;
            background: linear-gradient(to bottom, #2d2d30 0%, #252526 100%);
            border-bottom: 1px solid #3e3e42;
            display: flex;
            align-items: center;
            padding: 0 15px;
            z-index: 1000;
            color: #cccccc;
            font-size: 12px;
        }
        
        #status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
            background-color: #888;
            transition: background-color 0.3s;
        }
        
        #status-indicator.connected {
            background-color: #4ec9b0;
            box-shadow: 0 0 5px #4ec9b0;
        }
        
        #status-indicator.connecting {
            background-color: #f4bf75;
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        #status-indicator.disconnected {
            background-color: #f48771;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #status-text {
            flex: 1;
        }
        
        #terminal-wrapper {
            position: absolute;
            top: 30px;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #1e1e1e;
        }
        
        /* Loading overlay */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(30, 30, 30, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            color: #cccccc;
        }
        
        #loading-overlay.hidden {
            display: none;
        }
        
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #3e3e42;
            border-top-color: #4ec9b0;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* Xterm.js overrides for better appearance */
        .xterm {
            padding: 10px;
            height: 100%;
        }
        
        .xterm-viewport {
            background-color: #1e1e1e !important;
        }
        
        .xterm-screen {
            background-color: #1e1e1e !important;
        }
    </style>
</head>
<body>
    <!-- Status bar -->
    <div id="status-bar">
        <div id="status-indicator" class="connecting"></div>
        <div id="status-text">Connecting to SSH server...</div>
    </div>
    
    <!-- Loading overlay -->
    <div id="loading-overlay">
        <div class="spinner"></div>
        <div>Initializing terminal...</div>
    </div>
    
    <!-- Terminal wrapper -->
    <div id="terminal-wrapper">
        <div id="terminal-container">
            <div id="terminal"></div>
        </div>
    </div>
    
    <!-- Xterm.js and addons -->
    <script src="/static/xterm/xterm.js"></script>
    <script src="/static/xterm/xterm-addon-fit.js"></script>
    <script src="/static/xterm/xterm-addon-web-links.js"></script>
    
    <script>
        // Configuration
        const SERVER_ID = {{ server_id }};
        
        // State
        let term = null;
        let ws = null;
        let fitAddon = null;
        let webLinksAddon = null;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 3;
        let reconnectTimer = null;
        
        // Initialize terminal
        function initTerminal() {
            // Create xterm instance with VS Code-like theme
            term = new Terminal({
                cursorBlink: true,
                cursorStyle: 'block',
                fontFamily: "'Cascadia Code', 'Courier New', monospace",
                fontSize: 14,
                lineHeight: 1.2,
                theme: {
                    background: '#1e1e1e',
                    foreground: '#d4d4d4',
                    cursor: '#aeafad',
                    cursorAccent: '#1e1e1e',
                    selection: 'rgba(99, 150, 201, 0.3)',
                    black: '#000000',
                    red: '#cd3131',
                    green: '#0dbc79',
                    yellow: '#e5e510',
                    blue: '#2472c8',
                    magenta: '#bc3fbc',
                    cyan: '#11a8cd',
                    white: '#e5e5e5',
                    brightBlack: '#666666',
                    brightRed: '#f14c4c',
                    brightGreen: '#23d18b',
                    brightYellow: '#f5f543',
                    brightBlue: '#3b8eea',
                    brightMagenta: '#d670d6',
                    brightCyan: '#29b8db',
                    brightWhite: '#ffffff'
                },
                allowProposedApi: true,
                scrollback: 10000,
                convertEol: true
            });
            
            // Initialize addons
            fitAddon = new FitAddon.FitAddon();
            webLinksAddon = new WebLinksAddon.WebLinksAddon();
            
            term.loadAddon(fitAddon);
            term.loadAddon(webLinksAddon);
            
            // Open terminal
            term.open(document.getElementById('terminal'));
            
            // Fit terminal to container
            fitAddon.fit();
            
            // Handle terminal input
            term.onData(data => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'input',
                        data: data
                    }));
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', () => {
                fitAddon.fit();
                sendTerminalSize();
            });
            
            // Send terminal size on terminal resize
            term.onResize(({ cols, rows }) => {
                sendTerminalSize();
            });
            
            // Focus terminal
            term.focus();
            
            // Hide loading overlay
            document.getElementById('loading-overlay').classList.add('hidden');
            
            // Connect to WebSocket
            connectWebSocket();
        }
        
        // Send terminal size to server
        function sendTerminalSize() {
            if (ws && ws.readyState === WebSocket.OPEN && term) {
                ws.send(JSON.stringify({
                    type: 'resize',
                    cols: term.cols,
                    rows: term.rows
                }));
            }
        }
        
        // Update status
        function updateStatus(status, message) {
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');
            
            indicator.className = status;
            text.textContent = message;
        }
        
        // Connect to WebSocket
        function connectWebSocket() {
            try {
                const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                const wsUrl = `${protocol}//${window.location.host}/servers/${SERVER_ID}/ssh-console`;
                
                updateStatus('connecting', `Connecting to ${window.location.host}...`);
                
                ws = new WebSocket(wsUrl);
                
                ws.onopen = () => {
                    reconnectAttempts = 0;
                    updateStatus('connected', `Connected to SSH server`);
                    
                    // Send initial terminal size
                    setTimeout(() => {
                        sendTerminalSize();
                    }, 100);
                };
                
                ws.onmessage = (event) => {
                    handleMessage(event.data);
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    term.writeln('\r\n\x1b[31m✗ WebSocket connection error\x1b[0m');
                    updateStatus('disconnected', 'Connection error');
                };
                
                ws.onclose = () => {
                    updateStatus('disconnected', 'Disconnected from server');
                    term.writeln('\r\n\x1b[33m✗ Connection closed\x1b[0m\r\n');
                    
                    // Auto-reconnect
                    if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                        reconnectAttempts++;
                        const delay = Math.min(2000 * reconnectAttempts, 10000);
                        
                        updateStatus('connecting', `Reconnecting in ${delay/1000}s (attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`);
                        term.writeln(`\x1b[33mReconnecting in ${delay/1000} seconds...\x1b[0m`);
                        
                        reconnectTimer = setTimeout(connectWebSocket, delay);
                    } else {
                        updateStatus('disconnected', 'Connection failed - please refresh');
                        term.writeln('\x1b[31mReconnection failed. Please refresh the page.\x1b[0m');
                    }
                };
                
            } catch (error) {
                console.error('Failed to create WebSocket:', error);
                term.writeln('\x1b[31mFailed to establish connection\x1b[0m');
                updateStatus('disconnected', 'Failed to connect');
            }
        }
        
        // Handle WebSocket messages
        function handleMessage(data) {
            try {
                const msg = JSON.parse(data);
                
                switch (msg.type) {
                    case 'connected':
                        term.writeln(`\r\n\x1b[1;32m${msg.message}\x1b[0m\r\n`);
                        updateStatus('connected', msg.message);
                        break;
                        
                    case 'output':
                        term.write(msg.data);
                        break;
                        
                    case 'error':
                        term.writeln(`\r\n\x1b[1;31m✗ ${msg.message}\x1b[0m\r\n`);
                        updateStatus('disconnected', `Error: ${msg.message}`);
                        break;
                        
                    case 'warning':
                        term.writeln(`\r\n\x1b[1;33m⚠ ${msg.data || msg.message}\x1b[0m\r\n`);
                        break;
                        
                    default:
                        console.log('Unknown message type:', msg.type);
                }
            } catch (e) {
                // Not JSON, write as raw text
                term.write(data);
            }
        }
        
        // Cleanup on close
        window.addEventListener('beforeunload', () => {
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
            }
            
            if (ws && ws.readyState === WebSocket.OPEN) {
                try {
                    ws.send(JSON.stringify({ type: 'disconnect' }));
                    ws.close();
                } catch (e) {
                    // Ignore errors during cleanup
                }
            }
            
            if (term) {
                term.dispose();
            }
        });
        
        // Initialize when page loads
        window.addEventListener('load', initTerminal);
    </script>
</body>
</html>
